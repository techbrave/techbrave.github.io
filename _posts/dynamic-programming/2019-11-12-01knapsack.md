---
title: 0/1 Knapsack problem
layout: post
categories: [DynamicProgramming]
---

# 0/1 Knapsack (bounded)
状态：处理完前`i`个物品（决定哪些放到大小为`c`的背包）后，问题要求的解：能不能？最大获利？多少种
              不放      放，前提是不超重
`f(i, c) ~ f(i-1, c), f(i-1, c-w[i])`

- Equal Sum Partition
- Subset sum
- Minimum Sum difference
- Count of subset sum
- Target sum

# Knapsack (Unbounded)

`f(i, c) ~ f(i-1, c), f(i, c-w[i])`

# Fibonacci Numbers
转移方程直接给出来，就和第几个(序列下标）有关
`f[i] = f[i-1] + f[i-2]`

# Palindromic subsequence
// the longest palindromic subsequence, starting at index `i`, ending at index `j`
```
f[i][j]? ~ if s[i] == s[j] => f[i][j] = 2 + s[i+1][j-1]
           if s[i] != s[j] => f[i][j] = MAX{s[i+1][j], s[i][j-1]}
           
```

# Longest common substring 
// the longest common substring between s1, and s2?
f[i][j]: the longest common substring between s1 first i characters, and s2 first j characters
f[i][j]? ~ if s[i] == s[j] => f[i][j] = 1 + s[i-1][j-1]
           if s[i] != s[j] => f[i][j] = MAX{s[i-1][j], s[i][j-1]}
